/*
 * Copyright 2017-2019 NXP
 * To be used with S32 Configuration Tools under its Software License Agreement.
 */
 
// Load Utils script.
scriptApi.requireScript("codegeneratorUtils.js");

// This object opens a file and writes into the file 
OutputFile = function(fileName, coreId) {
    // name of the generated file
    this.fileName = fileName;
    // output stream 
    this.output = scriptApi.createFile(fileName, coreId);
    // write file content and "close" file object
    this.close = function(content) {
        this.output.write(content);
        this.fileName = "";
        this.output = null;
    }
} // OutputFile object prototype  

var hCfgFileSections = {
    'file_name': "",
    'misra_comments': "",
    'defines': "",
    'inst_defines': ""
}

var hFileSections = {
    'includes': "",
    'defines': "",
    'misra_comments': "",
    'global_vars_extern': "",
    'callback_function_extern': "",
    'init_functions': ""
}

var cFileSections = {
    'prototypes': ""
}

var commentPrepend = "comment_";

var initFunctions = new Array();

function clearGlobalObjects() {
  hCfgFileSections = {
    'file_name': "",
    'misra_comments': "",
    'defines': "",
    'inst_defines': ""
  }

  hFileSections = {
      'includes': "",
      'defines': "",
      'misra_comments': "",
      'global_vars_extern': "",
      'callback_function_extern': "",
      'init_functions': ""
  }

  cFileSections = {
      'prototypes': ""
  }

  initFunctions = new Array();
}

function getInitFunctionDefinitionString() {
  var initFunctionString = "";
  initFunctionString += '/*******************************************************************************\n';
  initFunctionString += ' * BOARD_InitBootPeripherals function\n';
  initFunctionString += ' ******************************************************************************/\n';

  initFunctionString += 'void BOARD_InitBootPeripherals(void)\n';
  initFunctionString += '{\n';

  for (var functionalGroupIndex in initFunctions) {
      initFunctionString += initFunctions[functionalGroupIndex];
  }

  initFunctionString += '}';
  return initFunctionString;
}

function getInitFunctionDeclarationString() {
  var initFunctionString = "";
  initFunctionString += '/*******************************************************************************\n';
  initFunctionString += ' * BOARD_InitBootPeripherals function\n';
  initFunctionString += ' ******************************************************************************/\n';

  initFunctionString += 'void BOARD_InitBootPeripherals(void);';
  return initFunctionString;
}

function removeDuplicitLines(string) {
    var linesArray = string.split('\n');
    uniqueArray = linesArray.filter(function(item, pos) {
        return linesArray.indexOf(item) == pos;
    });
    return uniqueArray.join("\n");
}

function renderHFile(componentInstancesConfigs) {

    outputString = "/***********************************************************************************************************************\n";
    outputString += " * This file was generated by the S32 Config Tools. Any manual edits made to this file\n";
    outputString += " * will be overwritten if the respective S32 Config Tools is used to update this file.\n";
    outputString += " **********************************************************************************************************************/\n\n";

    outputString += "#ifndef PERIPHERALS_H_\n"
    outputString += "#define PERIPHERALS_H_\n\n"


    if (hFileSections['includes'] != "") {
        outputString += "/*******************************************************************************\n";
        outputString += " * Included files \n"
        outputString += " ******************************************************************************/\n";
        outputString += removeDuplicitLines(hFileSections['includes']) + "\n";
    }

    if (hFileSections['defines'] != "") {
        outputString += "/*******************************************************************************\n";
        outputString += " * Definitions \n"
        outputString += " ******************************************************************************/\n";
        outputString += hFileSections['defines'] + "\n";
    }

    if (hFileSections['global_vars_extern'] != "") {
        outputString += "/*******************************************************************************\n";
        outputString += " * Global variables \n"
        outputString += " ******************************************************************************/\n";
        outputString += hFileSections['global_vars_extern'] + "\n";
    }

    if (hFileSections['callback_function_extern'] != "") {
        outputString += "/*******************************************************************************\n";
        outputString += " * Callback functions \n"
        outputString += " ******************************************************************************/\n";
        outputString += hFileSections['callback_function_extern'] + "\n";
    }

    if (hFileSections['init_functions'] != "") {
        outputString += "/*******************************************************************************\n";
        outputString += " * Initialization function \n"
        outputString += " ******************************************************************************/\n";
        outputString += hFileSections['init_functions'] + "\n";
    }

    outputString += "\n\n#endif /* PERIPHERALS_H_ */"
    return outputString;
}

function createHCfgFile(functionalGroups, coreId) {

    for (var functionalGroupsInd in functionalGroups) {
        if (functionalGroups[functionalGroupsInd].getCore() == coreId) {
            var fnGroupName = functionalGroups[functionalGroupsInd].getName();
            var componentInstancesConfigs = functionalGroups[functionalGroupsInd].getComponentInstances();

            // Iterate through all components and insert generated code
            // using js or Java classes or both.
            
            for (var j = 0; j < componentInstancesConfigs.length; j++) {
                var componentId = componentInstancesConfigs[j].getId().toString();

                if (componentInstancesConfigs[j].getError() == null) {
                    var componentSettings = componentInstancesConfigs[j].getChildren();
                    for (var componentSetting in componentSettings) {
                        var componentSettingCodeEmitter = componentSettings[componentSetting].getCodeEmitter();
                        try{
                            var configSets = componentSettings[componentSetting];
                            // Get js file which contains code generation for each component.
                            var codeGenFile = getSettingsValue(configSets, configSets.getName() + ".codegen_file");
                            if(codeGenFile != null){
                                // Load required script.
                                scriptApi.requireScript(codeGenFile);
                                // Get code generation class.
                                var className = getSettingsValue(configSets, configSets.getName() + ".codegen_class");
                                var codeGenClass = (Function('return new ' + className))()
                                // Call constructor.
                                codeGenClass.constructor.apply(codeGenClass, new Array(configSets));
                                // Execute preparation steps before code generation e.g. renames, error checking
                                if (typeof codeGenClass.prepareComponent === "function") {
                                    codeGenClass.prepareComponent();
                                }
                                // Add component specific info in header files sections e.g. defines, includes.
                                if (typeof codeGenClass.genHCfgFile === "function") {
                                    codeGenClass.genHCfgFile(hCfgFileSections);
                                }
                            }
                        }
                        catch(err)
                        {
                            scriptApi.logInfo(err);
                        }

                    }
                }
            }
            
    
            var fileNames = removeDuplicitLines(hCfgFileSections['file_name']);
            var linesArray = fileNames.split('\n');
            for (var fileName in linesArray)
            {
                var outputString = "";
                if (linesArray[fileName] != "") {
                
                    outputString += "/***********************************************************************************************************************\n";
                    outputString += " * This file was generated by the S32 Config Tools. Any manual edits made to this file\n";
                    outputString += " * will be overwritten if the respective S32 Config Tools is used to update this file.\n";
                    outputString += " **********************************************************************************************************************/\n";
                    outputString += "\n";
                    
                    var macro = linesArray[fileName].replace(".", "_");
                    outputString += "#ifndef " + macro.toUpperCase() + "\n";
                    outputString += "#define " + macro.toUpperCase() + "\n\n";
                    
                    outputString += "/**\n * @page misra_violations MISRA-C:2012 violations\n *\n";
                    outputString += " * @section [global]\n * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\n \* The global macro will be used in function call of the module.\n *\n";
                    outputString += " */\n";
                    
                    outputString += "/*******************************************************************************\n";
                    outputString += " * Definitions\n"
                    outputString += " ******************************************************************************/\n";

                    if (hCfgFileSections['defines'] != "") {

                        var tmp = removeDuplicitLines(hCfgFileSections['defines']);
                        var defines = tmp.split('\n');
                        for (var idx in defines)
                        {
                            if (defines[idx].indexOf(linesArray[fileName]) != -1)
                            {
                                if (defines[idx].indexOf(commentPrepend) == 0)
                                {
                                    /* assumes that the comment prepend is located at position 0 followed by filename and a character */
                                    var commentStart = linesArray[fileName].length + commentPrepend.length + 1;
                                    outputString += "/* " + defines[idx].substring(commentStart, defines[idx].length) + " */\n";
                                }
                                else
                                {
                                    var cMacro = "#define " + defines[idx].substring(linesArray[fileName].length + 1) + "\n";
                                    outputString += cMacro;
                                }
                            }
                        }
                    }

                    outputString += "\n";

                    if (hCfgFileSections['inst_defines'] != "") {

                        var instDefines = hCfgFileSections['inst_defines'];
                        var allInstDefines = instDefines.split('\n');
                        var tmp = removeDuplicitLines(hCfgFileSections['inst_defines'])
                        var uniqueInstDefines = tmp.split('\n');

                        var count = [];
                        var cMacro = "";
                        for (var idx in uniqueInstDefines)
                        {
                            if (uniqueInstDefines[idx].indexOf(linesArray[fileName]) != -1)
                            {
                                if (uniqueInstDefines[idx].indexOf(commentPrepend) == 0)
                                {
                                    var commentStart = linesArray[fileName].length + commentPrepend.length + 1;
                                    outputString += uniqueInstDefines[idx].substring(commentStart, uniqueInstDefines[idx].length) + "\n";
                                }
                                else
                                {
                                    var count = occurrences(instDefines, uniqueInstDefines[idx]);
                                    cMacro = uniqueInstDefines[idx].substring(linesArray[fileName].length + 1, uniqueInstDefines[idx].length);
                                    outputString += "#define " + cMacro + "  " + count + "\n";
                                }
                            }
                        }
                    }

                    outputString += "\n#endif /* " + macro.toUpperCase() + " */\n";
                    new OutputFile(linesArray[fileName], coreId).close(outputString);
                }
            }
        }

    }
}

function createHFile(functionalGroups, coreId) {

    for (var functionalGroupsInd in functionalGroups) {
        if (functionalGroups[functionalGroupsInd].getCore() == coreId) {
          var fnGroupName = functionalGroups[functionalGroupsInd].getName();
            var componentInstancesConfigs = functionalGroups[functionalGroupsInd].getComponentInstances();

            // Iterate through all components and insert generated code
            // using js or Java classes or both.
            for (var j = 0; j < componentInstancesConfigs.length; j++) {
                var instanceName = componentInstancesConfigs[j].getName();
                if (componentInstancesConfigs[j].getError() == null) {
                    var componentSettings = componentInstancesConfigs[j].getChildren();
                    for (var componentSetting in componentSettings) {
                        var componentSettingCodeEmitter = componentSettings[componentSetting].getCodeEmitter();

                        try{
                            var configSets = componentSettings[componentSetting];
                            // Get js file which contains code generation for each component.
                            var codeGenFile = getSettingsValue(configSets, configSets.getName() + ".codegen_file");
                            if(codeGenFile != null){
                                // Load required script.
                                scriptApi.requireScript(codeGenFile);
                                // Get code generation class.
                                var className = getSettingsValue(configSets, configSets.getName() + ".codegen_class");
                                var codeGenClass = (Function('return new ' + className))()
                                // Call constructor.
                                codeGenClass.constructor.apply(codeGenClass, new Array(configSets));
                                // Add component specific info in header files sections e.g. defines, includes.
                                codeGenClass.genHFile(hFileSections);
                            }
                        }
                        catch(err)
                        {
                            scriptApi.logInfo(err);
                        }
                        for (var hFileSection in hFileSections) {
                            //hFileSections[indHFileSections] += indHFileSections + " " + componetSettings[componetSetting].getName() + "\n";
                            if (componentSettingCodeEmitter.emit(hFileSection) != null) {
                                hFileSections[hFileSection] += componentSettingCodeEmitter.emit(hFileSection);
                            }
                        }
                    }
                }
            }
        }

    }

    return renderHFile(componentInstancesConfigs);
}

function createCFile(profile,functionalGroups, coreId) {
    var outputString = "";
    var prototypesString = "";
    var initializationCodesString = "";
    var initFunctionsString = "";
    var initFunctionsGrString = "";
    var componentExists = false;
    var componentCfgs = profile.getComponentConfigurations();

    outputString += "/***********************************************************************************************************************\n";
    outputString += " * This file was generated by the S32 Configuration Tools. Any manual edits made to this file\n";
    outputString += " * will be overwritten if the respective S32 Configuration Tools is used to update this file.\n";
    outputString += " **********************************************************************************************************************/\n\n";

    //Yaml code
    if (profile.getYaml() != null) {
      outputString += "/* clang-format off */" + '\n';
      outputString += profile.getYaml()+ '\n';
    }

    //Global component Yaml
    for (var iterator = componentCfgs.iterator(); iterator.hasNext();) {
      var component = iterator.next();
      if ((component.getYaml() != null) && (component.getGlobalConfigSet() != null)){
        outputString += component.getYaml() + '\n';
      }
    }

    if (profile.getYaml() != null) {
      outputString += "/* clang-format on */" + '\n\n';
    }

    for (var functionalGroupsInd in functionalGroups) {
        if (functionalGroups[functionalGroupsInd].getCore() == coreId) {
            var fnGroupName = functionalGroups[functionalGroupsInd].getName();
            var fnPrefix = functionalGroups[functionalGroupsInd].getIdPrefix();
            var componentInstancesConfigs = functionalGroups[functionalGroupsInd].getComponentInstances();
            var isComponent = componentInstancesConfigs.length > 0;
            if (isComponent) {
                componentExists = true;

                // Iterate through all components and insert generated code
                // using js or Java classes or both.
                for (var j = 0; j < componentInstancesConfigs.length; j++) {
                    var instanceName = componentInstancesConfigs[j].getName();
                    initializationCodesString += "/*******************************************************************************\n";
                    initializationCodesString += " * " + instanceName + " initialization code\n";
                    initializationCodesString += " ******************************************************************************/\n";

                    //Yaml code
                    if (componentInstancesConfigs[j].getYaml() != null) {
                      initializationCodesString += "/* clang-format off */" + '\n';
                      initializationCodesString += componentInstancesConfigs[j].getYaml() + '\n';
                      initializationCodesString += "/* clang-format on */";
                      initializationCodesString += '\n\n';
                    }
                    if (componentInstancesConfigs[j].getError() == null) {
                      var componentSettings = componentInstancesConfigs[j].getChildren();

                      var globalVarsString = ""
                      var initCodeArr = {
                          'global_vars': "",
                          'misra_comments': "",
                          'init_function_vars': "",
                          'init_function_preinit3': "",
                          'init_function_preinit2': "",
                          'init_function_preinit1': "",
                          'init_function_preinit0': "",
                          'init_function_body': "",
                          'init_function_postinit0': "",
                          'init_function_postinit1': "",
                          'init_function_postinit2': "",
                          'init_function_postinit3': ""
                      }
                      for (var indComponentSetting in componentSettings) {
                          var componetSettingCodeEmitter = componentSettings[indComponentSetting].getCodeEmitter();

                          try{
                                var configSets = componentSettings[indComponentSetting];
                                // Get js file which contains code generation for each component.
                                var codeGenFile = getSettingsValue(configSets, configSets.getName() + ".codegen_file");
                                if(codeGenFile != null){
                                    // Load required script.
                                    scriptApi.requireScript(codeGenFile);
                                    // Get code generation class.
                                    var className = getSettingsValue(configSets, configSets.getName() + ".codegen_class");                
                                    var codeGenClass = (Function('return new ' + className))()
                                    // Call constructor.
                                    codeGenClass.constructor.apply(codeGenClass, new Array(configSets));
                                    //scriptApi.logInfo(codeGenClass.toString());
                                    // Add component specific info in header files sections e.g. defines, includes.
                                    codeGenClass.genCFile(initCodeArr);
                                }
                            }
                            catch(err)
                            {
                                scriptApi.logInfo(err);
                            }
                          
                          for (var indInitCodeArr in initCodeArr) {
                              if (componetSettingCodeEmitter.emit(indInitCodeArr) != null) {
                                  initCodeArr[indInitCodeArr] += componetSettingCodeEmitter.emit(indInitCodeArr);
                              }
                          }
                      }

                      if (initCodeArr['global_vars'] != "") {
                          initializationCodesString += initCodeArr['global_vars'];
                      }
                    }
                    else {
                        scriptApi.logWarning("Configuration of the component " + instanceName + " of functional group " + fnGroupName + " is not valid.");
                    }

                }
            }
        }
    }

    if (componentExists) {
        outputString += "/*******************************************************************************\n";
        outputString += " * Included files \n"
        outputString += " ******************************************************************************/\n";
        outputString += "#include \"peripherals.h\"\n";
        outputString += "\n";
        if (prototypesString != "") {
            outputString += "/*******************************************************************************\n"
            outputString += " * Prototypes\n"
            outputString += " ******************************************************************************/\n"
            outputString += prototypesString + "\n";
        }

        outputString += initializationCodesString + "\n";
    }

    return outputString;
}

function coreUsed(functionalGroups, coreId) {
    for (functionalGroup in functionalGroups) {
        if (functionalGroups[functionalGroup].getCore() == coreId) {
            return true;
        }
    }
    return false;
}

function main() {
    var profile = scriptApi.getProfile();
    var functionalGroups = profile.getFunctionalGroups();
    var coresList = JSON.parse(profile.getMcuInfo().getCoresList());

    /* coresList is an array containing list of coreIds of each MCU cores, e. g.: ['core0', 'core1'] */
    var coresIds = Object.keys(coresList);

    for (var core = 0; core < coresIds.length; core++) {
        if (coreUsed(functionalGroups, coresIds[core])) {
            createHCfgFile(functionalGroups, coresIds[core]);
            createCFilePerComponent(profile, functionalGroups, coresIds[core]);
            createHFilePerComponent(functionalGroups, coresIds[core]);
            createProjectHeaderFile(profile, functionalGroups, coresIds[core]);
            clearGlobalObjects();
        }
    }
}

// check if clocks/pins tools are enabled
function checkToolEnabled(toolName){
	var expression = Java.type("com.nxp.swtools.provider.configuration.SharedConfigurationFactory");
    var tool = null;
    if (toolName == "clock")
	    tool = expression.getSharedConfigurationSingleton().getTools().getClock();
    else
        tool = expression.getSharedConfigurationSingleton().getTools().getPins();

    if(tool != null) {
		return tool.isEnabled();
	}
    return false;
} 

// create a unique header file per project
function createProjectHeaderFile(profile, functionalGroups, coreId) {
    var outputString = "";
    var componentExists = false;
    var componentCfgs = profile.getComponentConfigurations();

    outputString += "/***********************************************************************************************************************\n";
    outputString += " * This file was generated by the S32 Configuration Tools. Any manual edits made to this file\n";
    outputString += " * will be overwritten if the respective S32 Configuration Tools is used to update this file.\n";
    outputString += " **********************************************************************************************************************/\n\n";
    outputString += "#ifndef SDK_PROJECT_CONFIG_H_\n";
    outputString += "#define SDK_PROJECT_CONFIG_H_\n\n\n";
    outputString += "/**\n"
    outputString += " * @page misra_violations MISRA-C:2012 violations\n"
    outputString += " *\n"
    outputString += " * @section [global]\n"
    outputString += " * Violates MISRA 2012 Advisory Rule 2.5, Global macro not referenced.\n"
    outputString += " * The global macro will be used in function call of the module.\n"
    outputString += " *\n"
    outputString += " */\n"
    outputString += "/* Include header files for all configured components */\n";

    if (checkToolEnabled("clock"))
        outputString += "#include \"clock_config.h\"\n";
    if (checkToolEnabled("pins"))
        outputString += "#include \"pin_mux.h\"\n";

    for (var functionalGroupsInd in functionalGroups) {
        if (functionalGroups[functionalGroupsInd].getCore() == coreId) {
            var fnPrefix = functionalGroups[functionalGroupsInd].getIdPrefix();
            var componentInstancesConfigs = functionalGroups[functionalGroupsInd].getComponentInstances();
            var isComponent = componentInstancesConfigs.length > 0;
            if (isComponent) {
                componentExists = true;
                
                // Iterate through all components and insert an #include directive for each configuration file
                for (var j = 0; j < componentInstancesConfigs.length; j++) {
                    var instanceName = componentInstancesConfigs[j].getName();
                    var componentSettings = componentInstancesConfigs[j].getChildren();
                    for (var indComponentSetting in componentSettings) {
						var configSets = componentSettings[indComponentSetting];
						var mustGenFile = getSettingsValue(configSets, configSets.getName() + ".generate_header_and_c");
						var do_not_generate_file = false;
						if(mustGenFile != null){
							if(mustGenFile == 'false'){
								do_not_generate_file = true;
							}
						}

						if( do_not_generate_file == false){
							outputString += "#include \"peripherals_" + instanceName + ".h\"\n";
						}
					}
                }
            }
        }
    }

    outputString += "\n\n#endif /* SDK_PROJECT_CONFIG_H_ */\n";

    // Create the project header (included in main)
    new OutputFile("sdk_project_config.h", coreId).close(outputString);
}

// create the c file per functional group per component
function createCFilePerComponent(profile, functionalGroups, coreId) {
    var outputString = "";
    var initFunctionsString = "";
    var initFunctionsGrString = "";
    var componentExists = false;    
    var componentCfgs = profile.getComponentConfigurations();

    outputString += "/***********************************************************************************************************************\n";
    outputString += " * This file was generated by the S32 Configuration Tools. Any manual edits made to this file\n";
    outputString += " * will be overwritten if the respective S32 Configuration Tools is used to update this file.\n";
    outputString += " **********************************************************************************************************************/\n\n";

    //Yaml code
    if (profile.getYaml() != null) {
      outputString += "/* clang-format off */" + '\n';
      outputString += profile.getYaml()+ '\n';
    }

    //Global component Yaml
    for (var iterator = componentCfgs.iterator(); iterator.hasNext();) {
      var component = iterator.next();
      if ((component.getYaml() != null) && (component.getGlobalConfigSet() != null)){
        outputString += component.getYaml() + '\n';
      }
    }

    if (profile.getYaml() != null) {
      outputString += "/* clang-format on */" + '\n\n';
    }

    for (var functionalGroupsInd in functionalGroups) {
        if (functionalGroups[functionalGroupsInd].getCore() == coreId) {
            var fnGroupName = functionalGroups[functionalGroupsInd].getName();
            var fnPrefix = functionalGroups[functionalGroupsInd].getIdPrefix();
            var componentInstancesConfigs = functionalGroups[functionalGroupsInd].getComponentInstances();
            var isComponent = componentInstancesConfigs.length > 0;
            if (isComponent) {
                componentExists = true;
                
                // Iterate through all components and insert generated code
                // using js or Java classes or both.
                for (var j = 0; j < componentInstancesConfigs.length; j++) {
                    var instanceName = componentInstancesConfigs[j].getName();
                    var idComponent = componentInstancesConfigs[j].getComponent().getId();

                    var componentSettings = componentInstancesConfigs[j].getChildren();
                    for (var indComponentSetting in componentSettings) {
						var configSets = componentSettings[indComponentSetting];
						var mustGenFile = getSettingsValue(configSets, configSets.getName() + ".generate_header_and_c");
						var do_not_generate_file = false;
						if(mustGenFile != null){
							if(mustGenFile == 'false'){
								do_not_generate_file = true;
							}
						}

						if (componentExists) {
							var hIncludes = "/*******************************************************************************\n";
							hIncludes += " * Included files \n"
							hIncludes += " ******************************************************************************/\n";
							hIncludes += "#include \"peripherals_" + instanceName +".h\"\n";
							hIncludes += "\n";
						}

						if( do_not_generate_file == false){
							var initializationCodesString = initComponent(componentInstancesConfigs, fnGroupName, j);
							var outComponent = outputString + hIncludes + initializationCodesString + "\n";
							new OutputFile("peripherals_" + instanceName + ".c", coreId).close(outComponent);
						}
					}
                }
            }
        }
    }
}

function initComponent(componentInstancesConfigs, fnGroupName, index){
    var instanceName = componentInstancesConfigs[index].getName();
    var initializationCodesString = "/*******************************************************************************\n";
    initializationCodesString += " * " + instanceName + " initialization code\n";
    initializationCodesString += " ******************************************************************************/\n";

    //Yaml code
    if (componentInstancesConfigs[index].getYaml() != null) {
      initializationCodesString += "/* clang-format off */" + '\n';
      initializationCodesString += componentInstancesConfigs[index].getYaml() + '\n';
      initializationCodesString += "/* clang-format on */";
      initializationCodesString += '\n\n';
    }
    if (componentInstancesConfigs[index].getError() == null) {
      var componentSettings = componentInstancesConfigs[index].getChildren();

      var globalVarsString = ""
      var initCodeArr = {
          'global_vars': "",
          'misra_comments': "",
          'init_function_vars': "",
          'init_function_preinit3': "",
          'init_function_preinit2': "",
          'init_function_preinit1': "",
          'init_function_preinit0': "",
          'init_function_body': "",
          'init_function_postinit0': "",
          'init_function_postinit1': "",
          'init_function_postinit2': "",
          'init_function_postinit3': ""
      }
      for (var indComponentSetting in componentSettings) {
          var componetSettingCodeEmitter = componentSettings[indComponentSetting].getCodeEmitter();

          try{
                var configSets = componentSettings[indComponentSetting];
                // Get js file which contains code generation for each component.
                var codeGenFile = getSettingsValue(configSets, configSets.getName() + ".codegen_file");
                if(codeGenFile != null){
                    // Load required script.
                    scriptApi.requireScript(codeGenFile);
                    // Get code generation class.
                    var className = getSettingsValue(configSets, configSets.getName() + ".codegen_class");
                    var codeGenClass = (Function('return new ' + className))()
                    // Call constructor.
                    codeGenClass.constructor.apply(codeGenClass, new Array(configSets));
                    //scriptApi.logInfo(codeGenClass.toString());
                    // Add component specific info in header files sections e.g. defines, includes.
                    codeGenClass.genCFile(initCodeArr);
                }
            }
            catch(err)
            {
                scriptApi.logInfo(err);
            }
      
          for (var indInitCodeArr in initCodeArr) {
              if (componetSettingCodeEmitter.emit(indInitCodeArr) != null) {
                  initCodeArr[indInitCodeArr] += componetSettingCodeEmitter.emit(indInitCodeArr);
              }
          }
      }

      if (initCodeArr['misra_comments'] != "") {
          initializationCodesString += "/**\n * @page misra_violations MISRA-C:2012 violations\n *\n";
          initializationCodesString += initCodeArr['misra_comments']
          initializationCodesString += " */\n";
      }
      
      if (initCodeArr['global_vars'] != "") {
          initializationCodesString += initCodeArr['global_vars']
      }
    }
    else {
        scriptApi.logWarning("Configuration of the component " + instanceName + " of functional group " + fnGroupName + " is not valid.");
    }
    return initializationCodesString;
}

main();

//create .h file per functional group per component
function createHFilePerComponent(functionalGroups, coreId) {
    var isComponent = false;

    for (var functionalGroupsInd in functionalGroups) {
        if (functionalGroups[functionalGroupsInd].getCore() == coreId) {
            var componentInstancesConfigs = functionalGroups[functionalGroupsInd].getComponentInstances();
            isComponent = componentInstancesConfigs.length > 0;

            for (var j = 0; j < componentInstancesConfigs.length; j++) {
                var instanceName = componentInstancesConfigs[j].getName();

                var currentHFileSections = {
                    'includes': "",
                    'misra_comments': "",
                    'defines': "",
                    'global_vars_extern': "",
                    'callback_function_extern': "",
                    'init_functions': ""
                }

                if (componentInstancesConfigs[j].getError() == null) {
                    var componentSettings = componentInstancesConfigs[j].getChildren();

					for (var indComponentSetting in componentSettings) {
						var configSets = componentSettings[indComponentSetting];
						var mustGenFile = getSettingsValue(configSets, configSets.getName() + ".generate_header_and_c");
						var do_not_generate_file = false;
						if(mustGenFile != null){
							if(mustGenFile == 'false'){
								do_not_generate_file = true;
							}
						}
                    
                        var componentSettingCodeEmitter = componentSettings[indComponentSetting].getCodeEmitter();

                        try {
                            // Get js file which contains code generation for each component.
                            var codeGenFile = getSettingsValue(configSets, configSets.getName() + ".codegen_file");
                            if(codeGenFile != null){
                                // Load required script.
                                scriptApi.requireScript(codeGenFile);
                                // Get code generation class.
                                var className = getSettingsValue(configSets, configSets.getName() + ".codegen_class");
                                var codeGenClass = (Function('return new ' + className))()
                                // Call constructor.
                                codeGenClass.constructor.apply(codeGenClass, new Array(configSets));
                                // Add component specific info in header files sections e.g. defines, includes.
                                codeGenClass.genHFile(currentHFileSections);
                            }
                        } catch(err) {
                            scriptApi.logInfo(err);
                        }
                        for (var hFileSection in currentHFileSections) {
                            if (componentSettingCodeEmitter.emit(hFileSection) != null) {
                                currentHFileSections[hFileSection] += componentSettingCodeEmitter.emit(hFileSection);
                            }
                        }
                    }
    
                    if( do_not_generate_file == false){
                        var outputString = "/***********************************************************************************************************************\n";
                        outputString += " * This file was generated by the S32 Config Tools. Any manual edits made to this file\n";
                        outputString += " * will be overwritten if the respective S32 Config Tools is used to update this file.\n";
                        outputString += " **********************************************************************************************************************/\n\n";

                        outputString += "#ifndef " + instanceName +"_H\n"
                        outputString += "#define " + instanceName +"_H\n\n"
                        
                        if(currentHFileSections['misra_comments'] != "") {
                            outputString += "/**\n * @page misra_violations MISRA-C:2012 violations\n *\n";
                            outputString += currentHFileSections['misra_comments'];
                            outputString += " */\n";
                        }

                        if (currentHFileSections['includes'] != "") {
                            outputString += "/*******************************************************************************\n";
                            outputString += " * Included files \n"
                            outputString += " ******************************************************************************/\n";
                            outputString += removeDuplicitLines(currentHFileSections['includes']) + "\n";
                        }

                        if (currentHFileSections['defines'] != "") {
                            outputString += "/*******************************************************************************\n";
                            outputString += " * Definitions \n"
                            outputString += " ******************************************************************************/\n";
                            outputString += currentHFileSections['defines'] + "\n";
                        }

                        if (currentHFileSections['global_vars_extern'] != "") {
                            outputString += "/*******************************************************************************\n";
                            outputString += " * Global variables \n"
                            outputString += " ******************************************************************************/\n";
                            outputString += currentHFileSections['global_vars_extern'] + "\n";
                        }

                        if (currentHFileSections['callback_function_extern'] != "") {
                            outputString += "/*******************************************************************************\n";
                            outputString += " * Callback functions \n"
                            outputString += " ******************************************************************************/\n";
                            outputString += currentHFileSections['callback_function_extern'] + "\n";
                        }

                        if (currentHFileSections['init_functions'] != "") {
                            outputString += "/*******************************************************************************\n";
                            outputString += " * Initialization function \n"
                            outputString += " ******************************************************************************/\n";
                            outputString += currentHFileSections['init_functions'] + "\n";
                        }

                        outputString += "\n\n#endif /* " + instanceName +"_H */"
        
                        new OutputFile("peripherals_" + instanceName + ".h", coreId).close(outputString);
                    }
                }
            }
        }
    }
}
