<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>S32 SDK: LPUART Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top" style="height:auto; width:100%"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <img id="projectlogo" style="height:auto; width:100%" alt="Logo" src="s32sdk_logo_small.jpg"/>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__lpuart__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">LPUART Driver<div class="ingroups"><a class="el" href="group__lpuart.html">Low Power Universal Asynchronous Receiver-Transmitter (LPUART)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module covers the functionality of the Low Power Universal Asynchronous Receiver-Transmitter (LPUART) peripheral driver. </p>
<p>The LPUART driver implements serial communication using the LPUART module in the S32K1xx platforms. </p>
<h2>Features</h2>
<ul>
<li>Interrupt based, DMA based and polling communication</li>
<li>Provides blocking and non-blocking transmit and receive functions</li>
<li>Configurable baud rate</li>
<li>8/9/10 bits per char</li>
</ul>
<h2>Functionality</h2>
<p>In order to use the LPUART driver it must be first initialized, using <a class="el" href="group__lpuart__driver.html#gad7e73924e958a206552af4b389175a15" title="Initializes an LPUART operation instance. ">LPUART_DRV_Init()</a> function. Once initialized, it cannot be initialized again for the same LPUART module instance until it is de-initialized, using <a class="el" href="group__lpuart__driver.html#ga42db069613ffa67c19d3473983a478b9" title="Shuts down the LPUART by disabling interrupts and transmitter/receiver. ">LPUART_DRV_Deinit()</a>. The initialization function does the following operations:</p><ul>
<li>sets the baud rate</li>
<li>sets parity/bit count/stop bits count</li>
<li>initializes the state structure for the current instance Different LPUART module instances can function independently of each other. </li>
</ul>
<h3>Interrupt-based communication</h3>
<p>After initialization, a serial communication can be triggered by calling <a class="el" href="group__lpuart__driver.html#ga060314881e81245df319b8fe7493ee24" title="Sends data out through the LPUART module using a non-blocking method. This enables an a-sync method f...">LPUART_DRV_SendData()</a> function; this will save the reference of the data buffer received as parameter in the internal tx buffer pointer, then copy the first byte to the data register. The transmitter then automatically shifts the data and triggers a 'Transmit buffer empty' interrupt when all bits are shifted. The drivers interrupt handler takes care of transmitting the next byte in the buffer, by increasing the data pointer and decreasing the data size. The same sequence of operations is executed until all bytes in the tx buffer have been transmitted. </p>
<p>Similarly, data reception is triggered by calling <a class="el" href="group__lpuart__driver.html#gabd30b9b6d60bc5cf3af0cf71b284d2e2" title="Gets data from the LPUART module by using a non-blocking method. This enables an a-sync method for re...">LPUART_DRV_ReceiveData()</a> function, passing the rx buffer as parameter. When the receiver copies the received bits in the data register, the 'Receive buffer full' interrupt is triggered; the driver irq handler clears the flag by reading the received byte, saves it in the rx buffer, then increments the data pointer and decrements the data size. This is repeated until all bytes are received. </p>
<p>The workflow applies to send/receive operations using blocking method (triggered by <a class="el" href="group__lpuart__driver.html#ga1fff0cb6df4f26fcae9bf7c12bdd1b25" title="Sends data out through the LPUART module using a blocking method. ">LPUART_DRV_SendDataBlocking()</a> and <a class="el" href="group__lpuart__driver.html#ga88b6a0dcba2cb16b4795c0245c093de4" title="Gets data from the LPUART module by using a blocking method. Blocking means that the function does no...">LPUART_DRV_ReceiveDataBlocking()</a>), with the single difference that the send/receive function will not return until the send/receive operation is complete (all bytes are successfully transferred or a timeout occurred). The timeout for the blocking method is passed as parameter by the user. </p>
<h3>DMA-based communication</h3>
<p>In DMA operation, both blocking and non-blocking transmission methods configure a DMA channel to copy data from the buffer to the data register (for tx), or viceversa (for rx). The driver assumes the DMA channel is already allocated and the proper requests are routed to it via DMAMUX. After configuring the DMA channel, the driver enables DMA requests for rx/tx, then the DMA engine takes care of moving data to/from the data buffer. </p>
<h3>Polling mode</h3>
<p>The driver also provides polling methods for send and receive (<a class="el" href="group__lpuart__driver.html#gad05dad3640282aec04e99b78e58e107d" title="Send out multiple bytes of data using polling method. ">LPUART_DRV_SendDataPolling()</a> and <a class="el" href="group__lpuart__driver.html#gae30a859a48cb0b450f1e902a49f011d0" title="Receive multiple bytes of data using polling method. ">LPUART_DRV_ReceiveDataPolling()</a>). These functions are blocking (return only when the transfer is complete) and do not use interrupt or DMA services. The tx buffer empty and rx buffer full flags are polled by software in order to copy data to/from the data register. </p>
<h3>Error handling</h3>
<p>The driver treats the following errors on reception:</p><ul>
<li>rx overrun</li>
<li>parity error</li>
<li>framing error</li>
<li>noise error<br />
 In case any of these error events occur on the rx line during an ongoing reception, the transfer is aborted and rx status is updated accordingly. <a class="el" href="group__lpuart__driver.html#ga5818e3b8e12639d2ef2191dd787c0058" title="Returns whether the previous receive is complete. ">LPUART_DRV_GetReceiveStatus()</a> function can be called to retrieve the status of the last reception. If a receive callback is installed, it is called right after aborting the current transfer (with UART_EVENT_ERROR parameter). </li>
</ul>
<h3>Callbacks</h3>
<p>The driver provides callback notifications for asynchronous transfers. <a class="el" href="group__lpuart__driver.html#ga294bb3cf541d30320553a71bd17109d6" title="Installs callback function for the LPUART transmit. ">LPUART_DRV_InstallTxCallback()</a> function can be used for installing a callback routine to be called when the transmission is finished. The tx callback is called twice: first when the tx buffer becomes empty (no more data to be transmitted) - at this point the application can call <a class="el" href="group__lpuart__driver.html#ga99771ed81331ee20816798b602bd760f" title="Sets the internal driver reference to the tx buffer. ">LPUART_DRV_SetTxBuffer()</a> inside the callback in order to provide more data, resulting in a continuous transmission; if there is no more data to be transmitted, the callback is called again when the transmission is complete (all the bytes have been shifted out on the line). The event parameter in the callback signature differentiates these two calls - the values are UART_EVENT_TX_EMPTY and UART_EVENT_END_TRANSFER, respectively.<br />
 Similarly, <a class="el" href="group__lpuart__driver.html#gae51ddc27991f072589a707dc0a337c33" title="Installs callback function for the LPUART receive. ">LPUART_DRV_InstallRxCallback()</a> installs a callback routine for reception. This callback is called twice (UART_EVENT_RX_FULL and UART_EVENT_END_TRANSFER); if a new buffer is provided within the first callback call (<a class="el" href="group__lpuart__driver.html#ga3918d3cc0efedcd991a8ac01ace29170" title="Sets the internal driver reference to the rx buffer. ">LPUART_DRV_SetRxBuffer()</a>), the reception will continue without interruption. In case of an error detected during an ongoing reception, the transfer is aborted and the callback is called with UART_EVENT_ERROR parameter. The driver treats rx overrun, parity, framing and noise errors.<br />
 </p>
<h2>Important Notes</h2>
<ul>
<li>Before using the LPUART driver the module clock must be configured</li>
<li>The driver enables the interrupts for the corresponding LPUART module, but any interrupt priority must be done by the application</li>
<li>The board specific configurations must be done prior to driver calls; the driver has no influence on the functionality of the rx/tx pins - they must be configured by application</li>
<li>DMA module has to be initialized prior to LPUART usage in DMA mode; also, DMA channels need to be allocated for LPUART usage by the application (the driver only takes care of configuring the DMA channels received in the configuration structure)</li>
<li>For 9/10 bits characters, the application must provide the appropriate buffers; the size of the tx/rx buffers in this scenario needs to be an even number, as the transferred characters will be split in two bytes (bit 8 for 9-bits chars and bits 8 &amp; 9 for 10-bits chars will be stored in the subsequent byte). 9/10 bits chars are only supported in interrupt-based and polling communications</li>
<li>For 10-bits word length, parity cannot be enabled.</li>
<li><p class="startli">When the vector table is not in ram (<b>flash_vector_table</b> = 1):</p><ul>
<li>INT_SYS_InstallHandler shall check if the function pointer provided as parameter for the new handler is already present in the vector table for the given IRQ number.</li>
<li>The user will be required to manually add the correct handlers in the startup files </li>
</ul>
<h2>Integration guideline</h2>
</li>
</ul>
<h3>Compilation units</h3>
<p>The following files need to be compiled in the project: </p><pre class="fragment">${S32SDK_PATH}\platform\drivers\src\lpuart\lpuart_driver.c
${S32SDK_PATH}\platform\drivers\src\lpuart\lpuart_hw_access.c
${S32SDK_PATH}\platform\drivers\src\lpuart\lpuart_irq.c
</pre><h3>Include path</h3>
<p>The following paths need to be added to the include path of the toolchain: </p><pre class="fragment">${S32SDK_PATH}\platform\drivers\inc\
</pre><h3>Compile symbols</h3>
<p>No special symbols are required for this component</p>
<h3>Dependencies</h3>
<p><a class="el" href="group__clock__manager.html">Clock Manager</a> <a class="el" href="group__interrupt__manager.html">Interrupt Manager (Interrupt)</a> <a class="el" href="group__edma.html">Enhanced Direct Memory Access (eDMA)</a> </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlpuart__state__t.html">lpuart_state_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state of the LPUART driver.  <a href="structlpuart__state__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlpuart__user__config__t.html">lpuart_user_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART configuration structure.  <a href="structlpuart__user__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3015e4572692272a0f84ccb6ba7becbc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga3015e4572692272a0f84ccb6ba7becbc">lpuart_transfer_type_t</a> { <a class="el" href="group__lpuart__driver.html#gga3015e4572692272a0f84ccb6ba7becbca058941678b40a0b9a1300307cbffe019">LPUART_USING_DMA</a> = 0, 
<a class="el" href="group__lpuart__driver.html#gga3015e4572692272a0f84ccb6ba7becbcaf8b40a1a7ed6f8ac8cbb7705eff3fe01">LPUART_USING_INTERRUPTS</a>
 }<tr class="memdesc:ga3015e4572692272a0f84ccb6ba7becbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of LPUART transfer (based on interrupts or DMA).  <a href="group__lpuart__driver.html#ga3015e4572692272a0f84ccb6ba7becbc">More...</a><br /></td></tr>
<tr class="separator:ga3015e4572692272a0f84ccb6ba7becbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gadcdd4a875d1839a8ed41c162c2c67566"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gadcdd4a875d1839a8ed41c162c2c67566">lpuart_bit_count_per_char_t</a> { <a class="el" href="group__lpuart__driver.html#ggadcdd4a875d1839a8ed41c162c2c67566a7546bbb7ba2b9636ac563563293e011e">LPUART_8_BITS_PER_CHAR</a> = 0x0U, 
<a class="el" href="group__lpuart__driver.html#ggadcdd4a875d1839a8ed41c162c2c67566aa04b08420aa18211f8fc9123f7dddb31">LPUART_9_BITS_PER_CHAR</a> = 0x1U, 
<a class="el" href="group__lpuart__driver.html#ggadcdd4a875d1839a8ed41c162c2c67566a9653e838216fd309c8487434c158f653">LPUART_10_BITS_PER_CHAR</a> = 0x2U
 }<tr class="memdesc:gadcdd4a875d1839a8ed41c162c2c67566"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART number of bits in a character.  <a href="group__lpuart__driver.html#gadcdd4a875d1839a8ed41c162c2c67566">More...</a><br /></td></tr>
<tr class="separator:gadcdd4a875d1839a8ed41c162c2c67566"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga6fcd73abf900b8a17dab1f2b1f3f53c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga6fcd73abf900b8a17dab1f2b1f3f53c7">lpuart_parity_mode_t</a> { <a class="el" href="group__lpuart__driver.html#gga6fcd73abf900b8a17dab1f2b1f3f53c7a2567d3cdd8e92688e792ac5884ab3707">LPUART_PARITY_DISABLED</a> = 0x0U, 
<a class="el" href="group__lpuart__driver.html#gga6fcd73abf900b8a17dab1f2b1f3f53c7aa087a4fb5b9757ac47f68cca6cd395e7">LPUART_PARITY_EVEN</a> = 0x2U, 
<a class="el" href="group__lpuart__driver.html#gga6fcd73abf900b8a17dab1f2b1f3f53c7a039d62f3b08f82b05dcae185a9d01a26">LPUART_PARITY_ODD</a> = 0x3U
 }<tr class="memdesc:ga6fcd73abf900b8a17dab1f2b1f3f53c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART parity mode.  <a href="group__lpuart__driver.html#ga6fcd73abf900b8a17dab1f2b1f3f53c7">More...</a><br /></td></tr>
<tr class="separator:ga6fcd73abf900b8a17dab1f2b1f3f53c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga7540d87bc3fa8a605d8da53fe08219f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga7540d87bc3fa8a605d8da53fe08219f0">lpuart_stop_bit_count_t</a> { <a class="el" href="group__lpuart__driver.html#gga7540d87bc3fa8a605d8da53fe08219f0a05756cfc818d2dbd31d71f858a351944">LPUART_ONE_STOP_BIT</a> = 0x0U, 
<a class="el" href="group__lpuart__driver.html#gga7540d87bc3fa8a605d8da53fe08219f0a200c02367f74feb489fedab764a0f38a">LPUART_TWO_STOP_BIT</a> = 0x1U
 }<tr class="memdesc:ga7540d87bc3fa8a605d8da53fe08219f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART number of stop bits.  <a href="group__lpuart__driver.html#ga7540d87bc3fa8a605d8da53fe08219f0">More...</a><br /></td></tr>
<tr class="separator:ga7540d87bc3fa8a605d8da53fe08219f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LPUART Driver</h2></td></tr>
<tr class="memitem:ga7508e54678a463d9eac7539ec20b15d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga7508e54678a463d9eac7539ec20b15d2">LPUART_DRV_GetDefaultConfig</a> (<a class="el" href="structlpuart__user__config__t.html">lpuart_user_config_t</a> *lpuartUserConfig)</td></tr>
<tr class="memdesc:ga7508e54678a463d9eac7539ec20b15d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the LPUART configuration structure with default values.  <a href="#ga7508e54678a463d9eac7539ec20b15d2">More...</a><br /></td></tr>
<tr class="separator:ga7508e54678a463d9eac7539ec20b15d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7e73924e958a206552af4b389175a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gad7e73924e958a206552af4b389175a15">LPUART_DRV_Init</a> (uint32_t instance, <a class="el" href="structlpuart__state__t.html">lpuart_state_t</a> *lpuartStatePtr, const <a class="el" href="structlpuart__user__config__t.html">lpuart_user_config_t</a> *lpuartUserConfig)</td></tr>
<tr class="memdesc:gad7e73924e958a206552af4b389175a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an LPUART operation instance.  <a href="#gad7e73924e958a206552af4b389175a15">More...</a><br /></td></tr>
<tr class="separator:gad7e73924e958a206552af4b389175a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42db069613ffa67c19d3473983a478b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga42db069613ffa67c19d3473983a478b9">LPUART_DRV_Deinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga42db069613ffa67c19d3473983a478b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the LPUART by disabling interrupts and transmitter/receiver.  <a href="#ga42db069613ffa67c19d3473983a478b9">More...</a><br /></td></tr>
<tr class="separator:ga42db069613ffa67c19d3473983a478b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51ddc27991f072589a707dc0a337c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="callbacks_8h.html#a084c7c8aacf77963ba466f20c2b25a87">uart_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gae51ddc27991f072589a707dc0a337c33">LPUART_DRV_InstallRxCallback</a> (uint32_t instance, <a class="el" href="callbacks_8h.html#a084c7c8aacf77963ba466f20c2b25a87">uart_callback_t</a> function, void *callbackParam)</td></tr>
<tr class="memdesc:gae51ddc27991f072589a707dc0a337c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs callback function for the LPUART receive.  <a href="#gae51ddc27991f072589a707dc0a337c33">More...</a><br /></td></tr>
<tr class="separator:gae51ddc27991f072589a707dc0a337c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga294bb3cf541d30320553a71bd17109d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="callbacks_8h.html#a084c7c8aacf77963ba466f20c2b25a87">uart_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga294bb3cf541d30320553a71bd17109d6">LPUART_DRV_InstallTxCallback</a> (uint32_t instance, <a class="el" href="callbacks_8h.html#a084c7c8aacf77963ba466f20c2b25a87">uart_callback_t</a> function, void *callbackParam)</td></tr>
<tr class="memdesc:ga294bb3cf541d30320553a71bd17109d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs callback function for the LPUART transmit.  <a href="#ga294bb3cf541d30320553a71bd17109d6">More...</a><br /></td></tr>
<tr class="separator:ga294bb3cf541d30320553a71bd17109d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fff0cb6df4f26fcae9bf7c12bdd1b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga1fff0cb6df4f26fcae9bf7c12bdd1b25">LPUART_DRV_SendDataBlocking</a> (uint32_t instance, const uint8_t *txBuff, uint32_t txSize, uint32_t timeout)</td></tr>
<tr class="memdesc:ga1fff0cb6df4f26fcae9bf7c12bdd1b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data out through the LPUART module using a blocking method.  <a href="#ga1fff0cb6df4f26fcae9bf7c12bdd1b25">More...</a><br /></td></tr>
<tr class="separator:ga1fff0cb6df4f26fcae9bf7c12bdd1b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad05dad3640282aec04e99b78e58e107d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gad05dad3640282aec04e99b78e58e107d">LPUART_DRV_SendDataPolling</a> (uint32_t instance, const uint8_t *txBuff, uint32_t txSize)</td></tr>
<tr class="memdesc:gad05dad3640282aec04e99b78e58e107d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send out multiple bytes of data using polling method.  <a href="#gad05dad3640282aec04e99b78e58e107d">More...</a><br /></td></tr>
<tr class="separator:gad05dad3640282aec04e99b78e58e107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga060314881e81245df319b8fe7493ee24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga060314881e81245df319b8fe7493ee24">LPUART_DRV_SendData</a> (uint32_t instance, const uint8_t *txBuff, uint32_t txSize)</td></tr>
<tr class="memdesc:ga060314881e81245df319b8fe7493ee24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data out through the LPUART module using a non-blocking method. This enables an a-sync method for transmitting data. When used with a non-blocking receive, the LPUART can perform a full duplex operation. Non-blocking means that the function returns immediately. The application has to get the transmit status to know when the transmit is complete.  <a href="#ga060314881e81245df319b8fe7493ee24">More...</a><br /></td></tr>
<tr class="separator:ga060314881e81245df319b8fe7493ee24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd2533128a93a12edbed9934ec013e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga9dd2533128a93a12edbed9934ec013e4">LPUART_DRV_GetTransmitStatus</a> (uint32_t instance, uint32_t *bytesRemaining)</td></tr>
<tr class="memdesc:ga9dd2533128a93a12edbed9934ec013e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous transmit is complete.  <a href="#ga9dd2533128a93a12edbed9934ec013e4">More...</a><br /></td></tr>
<tr class="separator:ga9dd2533128a93a12edbed9934ec013e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10815260efd6f9d2462642ef3290dff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga10815260efd6f9d2462642ef3290dff7">LPUART_DRV_AbortSendingData</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga10815260efd6f9d2462642ef3290dff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates a non-blocking transmission early.  <a href="#ga10815260efd6f9d2462642ef3290dff7">More...</a><br /></td></tr>
<tr class="separator:ga10815260efd6f9d2462642ef3290dff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b6a0dcba2cb16b4795c0245c093de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga88b6a0dcba2cb16b4795c0245c093de4">LPUART_DRV_ReceiveDataBlocking</a> (uint32_t instance, uint8_t *rxBuff, uint32_t rxSize, uint32_t timeout)</td></tr>
<tr class="memdesc:ga88b6a0dcba2cb16b4795c0245c093de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets data from the LPUART module by using a blocking method. Blocking means that the function does not return until the receive is complete.  <a href="#ga88b6a0dcba2cb16b4795c0245c093de4">More...</a><br /></td></tr>
<tr class="separator:ga88b6a0dcba2cb16b4795c0245c093de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30a859a48cb0b450f1e902a49f011d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gae30a859a48cb0b450f1e902a49f011d0">LPUART_DRV_ReceiveDataPolling</a> (uint32_t instance, uint8_t *rxBuff, uint32_t rxSize)</td></tr>
<tr class="memdesc:gae30a859a48cb0b450f1e902a49f011d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive multiple bytes of data using polling method.  <a href="#gae30a859a48cb0b450f1e902a49f011d0">More...</a><br /></td></tr>
<tr class="separator:gae30a859a48cb0b450f1e902a49f011d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd30b9b6d60bc5cf3af0cf71b284d2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gabd30b9b6d60bc5cf3af0cf71b284d2e2">LPUART_DRV_ReceiveData</a> (uint32_t instance, uint8_t *rxBuff, uint32_t rxSize)</td></tr>
<tr class="memdesc:gabd30b9b6d60bc5cf3af0cf71b284d2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets data from the LPUART module by using a non-blocking method. This enables an a-sync method for receiving data. When used with a non-blocking transmission, the LPUART can perform a full duplex operation. Non-blocking means that the function returns immediately. The application has to get the receive status to know when the receive is complete.  <a href="#gabd30b9b6d60bc5cf3af0cf71b284d2e2">More...</a><br /></td></tr>
<tr class="separator:gabd30b9b6d60bc5cf3af0cf71b284d2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5818e3b8e12639d2ef2191dd787c0058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga5818e3b8e12639d2ef2191dd787c0058">LPUART_DRV_GetReceiveStatus</a> (uint32_t instance, uint32_t *bytesRemaining)</td></tr>
<tr class="memdesc:ga5818e3b8e12639d2ef2191dd787c0058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous receive is complete.  <a href="#ga5818e3b8e12639d2ef2191dd787c0058">More...</a><br /></td></tr>
<tr class="separator:ga5818e3b8e12639d2ef2191dd787c0058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7135296c744df2a3b4cd903fe2cf71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga5e7135296c744df2a3b4cd903fe2cf71">LPUART_DRV_AbortReceivingData</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga5e7135296c744df2a3b4cd903fe2cf71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates a non-blocking receive early.  <a href="#ga5e7135296c744df2a3b4cd903fe2cf71">More...</a><br /></td></tr>
<tr class="separator:ga5e7135296c744df2a3b4cd903fe2cf71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5f1a28116f1103ebb837d5bddd4dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gaea5f1a28116f1103ebb837d5bddd4dae">LPUART_DRV_SetBaudRate</a> (uint32_t instance, uint32_t desiredBaudRate)</td></tr>
<tr class="memdesc:gaea5f1a28116f1103ebb837d5bddd4dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the LPUART baud rate.  <a href="#gaea5f1a28116f1103ebb837d5bddd4dae">More...</a><br /></td></tr>
<tr class="separator:gaea5f1a28116f1103ebb837d5bddd4dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga667a09a90331b4b3f1976f6626d07435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga667a09a90331b4b3f1976f6626d07435">LPUART_DRV_GetBaudRate</a> (uint32_t instance, uint32_t *configuredBaudRate)</td></tr>
<tr class="memdesc:ga667a09a90331b4b3f1976f6626d07435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the LPUART baud rate.  <a href="#ga667a09a90331b4b3f1976f6626d07435">More...</a><br /></td></tr>
<tr class="separator:ga667a09a90331b4b3f1976f6626d07435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99771ed81331ee20816798b602bd760f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga99771ed81331ee20816798b602bd760f">LPUART_DRV_SetTxBuffer</a> (uint32_t instance, const uint8_t *txBuff, uint32_t txSize)</td></tr>
<tr class="memdesc:ga99771ed81331ee20816798b602bd760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the internal driver reference to the tx buffer.  <a href="#ga99771ed81331ee20816798b602bd760f">More...</a><br /></td></tr>
<tr class="separator:ga99771ed81331ee20816798b602bd760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3918d3cc0efedcd991a8ac01ace29170"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga3918d3cc0efedcd991a8ac01ace29170">LPUART_DRV_SetRxBuffer</a> (uint32_t instance, uint8_t *rxBuff, uint32_t rxSize)</td></tr>
<tr class="memdesc:ga3918d3cc0efedcd991a8ac01ace29170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the internal driver reference to the rx buffer.  <a href="#ga3918d3cc0efedcd991a8ac01ace29170">More...</a><br /></td></tr>
<tr class="separator:ga3918d3cc0efedcd991a8ac01ace29170"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gadcdd4a875d1839a8ed41c162c2c67566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#gadcdd4a875d1839a8ed41c162c2c67566">lpuart_bit_count_per_char_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART number of bits in a character. </p>
<p>Implements : lpuart_bit_count_per_char_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadcdd4a875d1839a8ed41c162c2c67566a7546bbb7ba2b9636ac563563293e011e"></a>LPUART_8_BITS_PER_CHAR&#160;</td><td class="fielddoc">
<p>8-bit data characters </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadcdd4a875d1839a8ed41c162c2c67566aa04b08420aa18211f8fc9123f7dddb31"></a>LPUART_9_BITS_PER_CHAR&#160;</td><td class="fielddoc">
<p>9-bit data characters </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadcdd4a875d1839a8ed41c162c2c67566a9653e838216fd309c8487434c158f653"></a>LPUART_10_BITS_PER_CHAR&#160;</td><td class="fielddoc">
<p>10-bit data characters </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="lpuart__driver_8h_source.html#l00053">53</a> of file <a class="el" href="lpuart__driver_8h_source.html">lpuart_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6fcd73abf900b8a17dab1f2b1f3f53c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga6fcd73abf900b8a17dab1f2b1f3f53c7">lpuart_parity_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART parity mode. </p>
<p>Implements : lpuart_parity_mode_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6fcd73abf900b8a17dab1f2b1f3f53c7a2567d3cdd8e92688e792ac5884ab3707"></a>LPUART_PARITY_DISABLED&#160;</td><td class="fielddoc">
<p>parity disabled </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6fcd73abf900b8a17dab1f2b1f3f53c7aa087a4fb5b9757ac47f68cca6cd395e7"></a>LPUART_PARITY_EVEN&#160;</td><td class="fielddoc">
<p>parity enabled, type even, bit setting: PE|PT = 10 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6fcd73abf900b8a17dab1f2b1f3f53c7a039d62f3b08f82b05dcae185a9d01a26"></a>LPUART_PARITY_ODD&#160;</td><td class="fielddoc">
<p>parity enabled, type odd, bit setting: PE|PT = 11 </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="lpuart__driver_8h_source.html#l00064">64</a> of file <a class="el" href="lpuart__driver_8h_source.html">lpuart_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7540d87bc3fa8a605d8da53fe08219f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga7540d87bc3fa8a605d8da53fe08219f0">lpuart_stop_bit_count_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART number of stop bits. </p>
<p>Implements : lpuart_stop_bit_count_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7540d87bc3fa8a605d8da53fe08219f0a05756cfc818d2dbd31d71f858a351944"></a>LPUART_ONE_STOP_BIT&#160;</td><td class="fielddoc">
<p>one stop bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7540d87bc3fa8a605d8da53fe08219f0a200c02367f74feb489fedab764a0f38a"></a>LPUART_TWO_STOP_BIT&#160;</td><td class="fielddoc">
<p>two stop bits </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="lpuart__driver_8h_source.html#l00075">75</a> of file <a class="el" href="lpuart__driver_8h_source.html">lpuart_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3015e4572692272a0f84ccb6ba7becbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga3015e4572692272a0f84ccb6ba7becbc">lpuart_transfer_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of LPUART transfer (based on interrupts or DMA). </p>
<p>Implements : lpuart_transfer_type_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga3015e4572692272a0f84ccb6ba7becbca058941678b40a0b9a1300307cbffe019"></a>LPUART_USING_DMA&#160;</td><td class="fielddoc">
<p>The driver will use DMA to perform UART transfer </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3015e4572692272a0f84ccb6ba7becbcaf8b40a1a7ed6f8ac8cbb7705eff3fe01"></a>LPUART_USING_INTERRUPTS&#160;</td><td class="fielddoc">
<p>The driver will use interrupts to perform UART transfer </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="lpuart__driver_8h_source.html#l00043">43</a> of file <a class="el" href="lpuart__driver_8h_source.html">lpuart_driver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5e7135296c744df2a3b4cd903fe2cf71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_AbortReceivingData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates a non-blocking receive early. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the receiving was successful or not. </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00891">891</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga10815260efd6f9d2462642ef3290dff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_AbortSendingData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates a non-blocking transmission early. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the aborting is successful or not. </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00580">580</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga42db069613ffa67c19d3473983a478b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_Deinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuts down the LPUART by disabling interrupts and transmitter/receiver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS if successful; STATUS_ERROR if an error occurred </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00278">278</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga667a09a90331b4b3f1976f6626d07435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_DRV_GetBaudRate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>configuredBaudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the LPUART baud rate. </p>
<p>This function returns the LPUART configured baud rate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">instance</td><td>LPUART instance number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">configuredBaudRate</td><td>LPUART configured baud rate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l01036">1036</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7508e54678a463d9eac7539ec20b15d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_DRV_GetDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlpuart__user__config__t.html">lpuart_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>lpuartUserConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the LPUART configuration structure with default values. </p>
<p>This function initializes a configuration structure received from the application with default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpuartUserConfig</td><td>user configuration structure of type <a class="el" href="structlpuart__user__config__t.html" title="LPUART configuration structure. ">lpuart_user_config_t</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00145">145</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5818e3b8e12639d2ef2191dd787c0058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_GetReceiveStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytesRemaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the previous receive is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">bytesRemaining</td><td>pointer to value that is filled with the number of bytes that still need to be received in the active transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In DMA mode, this parameter may not be accurate, in case the transfer completes right after calling this function; in this edge-case, the parameter will reflect the initial transfer size, due to automatic reloading of the major loop count in the DMA transfer descriptor. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The receive status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_SUCCESS</td><td>the receive has completed successfully. </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>the receive is still in progress. <em>bytesReceived</em> will be filled with the number of bytes that have been received so far. </td></tr>
    <tr><td class="paramname">STATUS_UART_ABORTED</td><td>The receive was aborted. </td></tr>
    <tr><td class="paramname">STATUS_TIMEOUT</td><td>A timeout was reached. </td></tr>
    <tr><td class="paramname">STATUS_UART_RX_OVERRUN,STATUS_UART_FRAMING_ERROR,STATUS_UART_PARITY_ERROR,or</td><td>STATUS_UART_NOISE_ERROR, STATUS_ERROR An error occurred during reception. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00846">846</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9dd2533128a93a12edbed9934ec013e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_GetTransmitStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytesRemaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the previous transmit is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">bytesRemaining</td><td>Pointer to value that is populated with the number of bytes that have been sent in the active transfer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In DMA mode, this parameter may not be accurate, in case the transfer completes right after calling this function; in this edge-case, the parameter will reflect the initial transfer size, due to automatic reloading of the major loop count in the DMA transfer descriptor. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The transmit status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_SUCCESS</td><td>The transmit has completed successfully. </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>The transmit is still in progress. <em>bytesRemaining</em> will be filled with the number of bytes that are yet to be transmitted. </td></tr>
    <tr><td class="paramname">STATUS_UART_ABORTED</td><td>The transmit was aborted. </td></tr>
    <tr><td class="paramname">STATUS_TIMEOUT</td><td>A timeout was reached. </td></tr>
    <tr><td class="paramname">STATUS_ERROR</td><td>An error occurred. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00534">534</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad7e73924e958a206552af4b389175a15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_Init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlpuart__state__t.html">lpuart_state_t</a> *&#160;</td>
          <td class="paramname"><em>lpuartStatePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlpuart__user__config__t.html">lpuart_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>lpuartUserConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an LPUART operation instance. </p>
<p>The caller provides memory for the driver state structures during initialization. The user must select the LPUART clock source in the application to initialize the LPUART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">lpuartUserConfig</td><td>user configuration structure of type <a class="el" href="structlpuart__user__config__t.html" title="LPUART configuration structure. ">lpuart_user_config_t</a> </td></tr>
    <tr><td class="paramname">lpuartStatePtr</td><td>pointer to the LPUART driver state structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS if successful; STATUS_ERROR if an error occurred </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00181">181</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae51ddc27991f072589a707dc0a337c33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="callbacks_8h.html#a084c7c8aacf77963ba466f20c2b25a87">uart_callback_t</a> LPUART_DRV_InstallRxCallback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="callbacks_8h.html#a084c7c8aacf77963ba466f20c2b25a87">uart_callback_t</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs callback function for the LPUART receive. </p>
<dl class="section note"><dt>Note</dt><dd>After a callback is installed, it bypasses part of the LPUART IRQHandler logic. Therefore, the callback needs to handle the indexes of txBuff and txSize.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The LPUART instance number. </td></tr>
    <tr><td class="paramname">function</td><td>The LPUART receive callback function. </td></tr>
    <tr><td class="paramname">rxBuff</td><td>The receive buffer used inside IRQHandler. This buffer must be kept as long as the callback is alive. </td></tr>
    <tr><td class="paramname">callbackParam</td><td>The LPUART receive callback parameter pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Former LPUART receive callback function pointer. </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00319">319</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga294bb3cf541d30320553a71bd17109d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="callbacks_8h.html#a084c7c8aacf77963ba466f20c2b25a87">uart_callback_t</a> LPUART_DRV_InstallTxCallback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="callbacks_8h.html#a084c7c8aacf77963ba466f20c2b25a87">uart_callback_t</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs callback function for the LPUART transmit. </p>
<dl class="section note"><dt>Note</dt><dd>After a callback is installed, it bypasses part of the LPUART IRQHandler logic. Therefore, the callback needs to handle the indexes of txBuff and txSize.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The LPUART instance number. </td></tr>
    <tr><td class="paramname">function</td><td>The LPUART transmit callback function. </td></tr>
    <tr><td class="paramname">txBuff</td><td>The transmit buffer used inside IRQHandler. This buffer must be kept as long as the callback is alive. </td></tr>
    <tr><td class="paramname">callbackParam</td><td>The LPUART transmit callback parameter pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Former LPUART transmit callback function pointer. </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00342">342</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabd30b9b6d60bc5cf3af0cf71b284d2e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_ReceiveData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets data from the LPUART module by using a non-blocking method. This enables an a-sync method for receiving data. When used with a non-blocking transmission, the LPUART can perform a full duplex operation. Non-blocking means that the function returns immediately. The application has to get the receive status to know when the receive is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">rxBuff</td><td>buffer containing 8-bit read data chars received </td></tr>
    <tr><td class="paramname">rxSize</td><td>the number of bytes to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS if successful; STATUS_BUSY if the resource is busy </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00803">803</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga88b6a0dcba2cb16b4795c0245c093de4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_ReceiveDataBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets data from the LPUART module by using a blocking method. Blocking means that the function does not return until the receive is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">rxBuff</td><td>buffer containing 8-bit read data chars received </td></tr>
    <tr><td class="paramname">rxSize</td><td>the number of bytes to receive </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS if successful; STATUS_TIMEOUT if the timeout was reached; STATUS_BUSY if the resource is busy; STATUS_UART_FRAMING_ERROR if a framing error occurred; STATUS_UART_NOISE_ERROR if a noise error occurred; STATUS_UART_PARITY_ERROR if a parity error occurred; STATUS_UART_RX_OVERRUN if an overrun error occurred; STATUS_ERROR if a DMA error occurred; </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00618">618</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae30a859a48cb0b450f1e902a49f011d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_ReceiveDataPolling </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive multiple bytes of data using polling method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number. </td></tr>
    <tr><td class="paramname">rxBuff</td><td>The buffer pointer which saves the data to be received. </td></tr>
    <tr><td class="paramname">rxSize</td><td>Size of data need to be received in unit of byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS if the transaction is successful; STATUS_BUSY if the resource is busy; STATUS_UART_RX_OVERRUN if an overrun error occurred. </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00683">683</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga060314881e81245df319b8fe7493ee24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_SendData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data out through the LPUART module using a non-blocking method. This enables an a-sync method for transmitting data. When used with a non-blocking receive, the LPUART can perform a full duplex operation. Non-blocking means that the function returns immediately. The application has to get the transmit status to know when the transmit is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">txBuff</td><td>source buffer containing 8-bit data chars to send </td></tr>
    <tr><td class="paramname">txSize</td><td>the number of bytes to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS if successful; STATUS_BUSY if the resource is busy; </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00490">490</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1fff0cb6df4f26fcae9bf7c12bdd1b25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_SendDataBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends data out through the LPUART module using a blocking method. </p>
<p>Blocking means that the function does not return until the transmission is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">txBuff</td><td>source buffer containing 8-bit data chars to send </td></tr>
    <tr><td class="paramname">txSize</td><td>the number of bytes to send </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS if successful; STATUS_TIMEOUT if the timeout was reached; STATUS_BUSY if the resource is busy; STATUS_ERROR if an error occurred </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00365">365</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad05dad3640282aec04e99b78e58e107d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_SendDataPolling </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send out multiple bytes of data using polling method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number. </td></tr>
    <tr><td class="paramname">txBuff</td><td>The buffer pointer which saves the data to be sent. </td></tr>
    <tr><td class="paramname">txSize</td><td>Size of data to be sent in unit of byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS if successful; STATUS_BUSY if the resource is busy; </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00430">430</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaea5f1a28116f1103ebb837d5bddd4dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_SetBaudRate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredBaudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the LPUART baud rate. </p>
<p>This function configures the LPUART baud rate. In some LPUART instances the user must disable the transmitter/receiver before calling this function. Generally, this may be applied to all LPUARTs to ensure safe operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number. </td></tr>
    <tr><td class="paramname">desiredBaudRate</td><td>LPUART desired baud rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_BUSY if called during an on-going transfer, STATUS_SUCCESS otherwise </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l00931">931</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3918d3cc0efedcd991a8ac01ace29170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_SetRxBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the internal driver reference to the rx buffer. </p>
<p>This function can be called from the rx callback to provide the driver with a new buffer, for continuous reception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">rxBuff</td><td>destination buffer containing 8-bit data chars to receive </td></tr>
    <tr><td class="paramname">rxSize</td><td>the number of bytes to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l01089">1089</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga99771ed81331ee20816798b602bd760f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> LPUART_DRV_SetTxBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the internal driver reference to the tx buffer. </p>
<p>This function can be called from the tx callback to provide the driver with a new buffer, for continuous transmission.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>LPUART instance number </td></tr>
    <tr><td class="paramname">txBuff</td><td>source buffer containing 8-bit data chars to send </td></tr>
    <tr><td class="paramname">txSize</td><td>the number of bytes to send </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>STATUS_SUCCESS </dd></dl>

<p>Definition at line <a class="el" href="lpuart__driver_8c_source.html#l01065">1065</a> of file <a class="el" href="lpuart__driver_8c_source.html">lpuart_driver.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 11 2021 08:16:08 for S32 SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
